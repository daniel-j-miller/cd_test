[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A place where I might try to put some useful things one day."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dataseance",
    "section": "",
    "text": "Yeah NAh\n\n\n\n\n\n\n\ncode\n\n\nR\n\n\n\n\nA short post about filtering/subsetting data when there are NA values in R\n\n\n\n\n\n\nDec 3, 2024\n\n\nDan Miller\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!!!!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/Yeah_NAh/index.html",
    "href": "posts/Yeah_NAh/index.html",
    "title": "Yeah NAh",
    "section": "",
    "text": "When we want to subset some data in R we have a few options, but really all of them under the hood are returning our data (often rows) based on logical, numeric or character indices.\nSo in the simplest form in base R we can use the [ function to return the elements we want.\n\n# Return the first two elements using numeric indices:\nc(1,2,3)[1:2]\n\n[1] 1 2\n\n\n\n# And now Boolean:\nc(1,2,3)[c(TRUE,TRUE,FALSE)]\n\n[1] 1 2\n\n\n\n# And how we would generally do it, by actually testing for equality\ndat &lt;- c(1,2,3)\ndat[dat != 3]\n\n[1] 1 2\n\n\nBut what if our data has NA values?\n\n# Filtering by testing equality/inequality with an NA value\ndat &lt;- c(1,2,3,NA)\ndat[dat != 3]\n\n[1]  1  2 NA\n\n\nThat looks ok, right? It‚Äôs returning all the things that don‚Äôt equal 3. But is it really return the NA value from the original dat?\nConsidering that we said we subset with logical, numeric or character indices, what does dat != 3 return?\n\ndat != 3\n\n[1]  TRUE  TRUE FALSE    NA\n\n\nNA is not one of the valid values for indexing. The documentation for [ gives us a clue:\n\nNAs in indexing: When extracting, a numerical, logical or character NA index picks an unknown element and so returns NA in the corresponding element of a logical, integer, numeric, complex or character result, and NULL for a list.\n\nSo what does it matter? Well, it becomes clearer that it‚Äôs not returning our original NA when we look at more complex data.\n\ndat &lt;- data.frame(name = LETTERS[1:16], \n                  feature = sample(c(1:3,NA),16,replace = TRUE))\ndat\n\n   name feature\n1     A       2\n2     B      NA\n3     C       3\n4     D       1\n5     E       2\n6     F       3\n7     G      NA\n8     H       3\n9     I       2\n10    J      NA\n11    K      NA\n12    L       2\n13    M       2\n14    N       1\n15    O       3\n16    P       1\n\n\n\ndat_base &lt;- dat[dat$feature != 3,]\ndat_base\n\n     name feature\n1       A       2\nNA   &lt;NA&gt;      NA\n4       D       1\n5       E       2\nNA.1 &lt;NA&gt;      NA\n9       I       2\nNA.2 &lt;NA&gt;      NA\nNA.3 &lt;NA&gt;      NA\n12      L       2\n13      M       2\n14      N       1\n16      P       1\n\n\nThe rows where feature was NA are not actually returned, instead a whole missing row is returned in their place. This is somewhat unexpected unless you know what is happening and it‚Äôs probably unlikely to be the desired result."
  },
  {
    "objectID": "posts/Yeah_NAh/index.html#filtering-in-r",
    "href": "posts/Yeah_NAh/index.html#filtering-in-r",
    "title": "Yeah NAh",
    "section": "",
    "text": "When we want to subset some data in R we have a few options, but really all of them under the hood are returning our data (often rows) based on logical, numeric or character indices.\nSo in the simplest form in base R we can use the [ function to return the elements we want.\n\n# Return the first two elements using numeric indices:\nc(1,2,3)[1:2]\n\n[1] 1 2\n\n\n\n# And now Boolean:\nc(1,2,3)[c(TRUE,TRUE,FALSE)]\n\n[1] 1 2\n\n\n\n# And how we would generally do it, by actually testing for equality\ndat &lt;- c(1,2,3)\ndat[dat != 3]\n\n[1] 1 2\n\n\nBut what if our data has NA values?\n\n# Filtering by testing equality/inequality with an NA value\ndat &lt;- c(1,2,3,NA)\ndat[dat != 3]\n\n[1]  1  2 NA\n\n\nThat looks ok, right? It‚Äôs returning all the things that don‚Äôt equal 3. But is it really return the NA value from the original dat?\nConsidering that we said we subset with logical, numeric or character indices, what does dat != 3 return?\n\ndat != 3\n\n[1]  TRUE  TRUE FALSE    NA\n\n\nNA is not one of the valid values for indexing. The documentation for [ gives us a clue:\n\nNAs in indexing: When extracting, a numerical, logical or character NA index picks an unknown element and so returns NA in the corresponding element of a logical, integer, numeric, complex or character result, and NULL for a list.\n\nSo what does it matter? Well, it becomes clearer that it‚Äôs not returning our original NA when we look at more complex data.\n\ndat &lt;- data.frame(name = LETTERS[1:16], \n                  feature = sample(c(1:3,NA),16,replace = TRUE))\ndat\n\n   name feature\n1     A       2\n2     B      NA\n3     C       3\n4     D       1\n5     E       2\n6     F       3\n7     G      NA\n8     H       3\n9     I       2\n10    J      NA\n11    K      NA\n12    L       2\n13    M       2\n14    N       1\n15    O       3\n16    P       1\n\n\n\ndat_base &lt;- dat[dat$feature != 3,]\ndat_base\n\n     name feature\n1       A       2\nNA   &lt;NA&gt;      NA\n4       D       1\n5       E       2\nNA.1 &lt;NA&gt;      NA\n9       I       2\nNA.2 &lt;NA&gt;      NA\nNA.3 &lt;NA&gt;      NA\n12      L       2\n13      M       2\n14      N       1\n16      P       1\n\n\nThe rows where feature was NA are not actually returned, instead a whole missing row is returned in their place. This is somewhat unexpected unless you know what is happening and it‚Äôs probably unlikely to be the desired result."
  },
  {
    "objectID": "posts/Yeah_NAh/index.html#filtering-with-nas",
    "href": "posts/Yeah_NAh/index.html#filtering-with-nas",
    "title": "Yeah NAh",
    "section": "Filtering with NAs",
    "text": "Filtering with NAs\ndplr::filter() and base::subset() are a little clearer and provide more likely results when filtering with NA values present. First subset(): &gt; ‚ÄúFor ordinary vectors, the result is simply x[subset & !is.na(subset)].‚Äù\n\nsubset(dat, feature != 3)\n\n   name feature\n1     A       2\n4     D       1\n5     E       2\n9     I       2\n12    L       2\n13    M       2\n14    N       1\n16    P       1\n\n\nAnd dplyr::filter() is clearer again:\n\n\n\n\n\n\nFrom the dplyr::filter() documentation:\n\n\n\n‚ÄúThe filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.‚Äù\nüëÄ dplyr::filter() documentation\n\n\n\ndat |&gt; dplyr::filter(feature != 3)\n\n  name feature\n1    A       2\n2    D       1\n3    E       2\n4    I       2\n5    L       2\n6    M       2\n7    N       1\n8    P       1"
  },
  {
    "objectID": "posts/Yeah_NAh/index.html#but-what-if-i-want-the-na-rows",
    "href": "posts/Yeah_NAh/index.html#but-what-if-i-want-the-na-rows",
    "title": "Yeah NAh",
    "section": "But what if I want the NA rows?!?!",
    "text": "But what if I want the NA rows?!?!\nWell, we need to create a vector that explicitly includes the NA values:\n\ndat$feature != 3 | is.na(dat$feature)\n\n [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE FALSE  TRUE\n\n\n\ndat[dat$feature != 3 | is.na(dat$feature),]\n\n   name feature\n1     A       2\n2     B      NA\n4     D       1\n5     E       2\n7     G      NA\n9     I       2\n10    J      NA\n11    K      NA\n12    L       2\n13    M       2\n14    N       1\n16    P       1\n\nsubset(dat, feature != 3 | is.na(feature))\n\n   name feature\n1     A       2\n2     B      NA\n4     D       1\n5     E       2\n7     G      NA\n9     I       2\n10    J      NA\n11    K      NA\n12    L       2\n13    M       2\n14    N       1\n16    P       1\n\ndat |&gt; dplyr::filter(feature != 3 | is.na(feature))\n\n   name feature\n1     A       2\n2     B      NA\n3     D       1\n4     E       2\n5     G      NA\n6     I       2\n7     J      NA\n8     K      NA\n9     L       2\n10    M       2\n11    N       1\n12    P       1"
  }
]