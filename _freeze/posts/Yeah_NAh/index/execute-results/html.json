{
  "hash": "a89be782535e5c76d3ec9c76d81f68bf",
  "result": {
    "markdown": "---\ntitle: \"Yeah NAh\"\nauthor: \"Dan Miller\"\ndescription: \"A short post about filtering/subsetting data when there are NA values in R\"\nimage: thumb.jpg\ndate: \"2024-12-03\"\ncategories: [code, R]\n---\n\n\n\n## Filtering in R\n\nWhen we want to subset some data in R we have a few options, but really all of them under the hood are returning our data (often rows) based on logical, numeric or character indices.\n\nSo in the simplest form in base R we can use the ``[`` function to return the elements we want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return the first two elements using numeric indices:\nc(1,2,3)[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# And now Boolean:\nc(1,2,3)[c(TRUE,TRUE,FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# And how we would generally do it, by actually testing for equality\ndat <- c(1,2,3)\ndat[dat != 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\nBut what if our data has `NA` values?\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtering by testing equality/inequality with an NA value\ndat <- c(1,2,3,NA)\ndat[dat != 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2 NA\n```\n:::\n:::\n\nThat looks ok, right? It's returning all the things that don't equal 3. But is it really return the `NA` value from the original `dat`? \n\nConsidering that we said we subset with logical, numeric or character indices, what does `dat != 3` return?\n\n::: {.cell}\n\n```{.r .cell-code}\ndat != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE    NA\n```\n:::\n:::\n\n`NA` is not one of the valid values for indexing. The documentation for `[` gives us a clue:\n\n> **NAs in indexing**:\n> When extracting, a numerical, logical or character *NA index* picks an *unknown element* and so returns NA in the corresponding element of a logical, integer, numeric, complex or character result, and NULL for a list. \n\nSo what does it matter? Well, it becomes clearer that it's not returning our original NA when we look at more complex data.\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(name = LETTERS[1:16], \n                  feature = sample(c(1:3,NA),16,replace = TRUE))\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n2     B       3\n3     C       3\n4     D       3\n5     E       2\n6     F      NA\n7     G       3\n8     H      NA\n9     I       2\n10    J       1\n11    K       2\n12    L       3\n13    M       2\n14    N       3\n15    O       2\n16    P       3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_base <- dat[dat$feature != 3,]\ndat_base\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name feature\n1       A       1\n5       E       2\nNA   <NA>      NA\nNA.1 <NA>      NA\n9       I       2\n10      J       1\n11      K       2\n13      M       2\n15      O       2\n```\n:::\n:::\n\nThe rows where `feature` was `NA` are not actually returned, instead a whole missing row is returned in their place. This is somewhat unexpected unless you know what is happening and it's probably unlikely to be the desired result.\n\n## Filtering with NAs\n\n`dplyr::filter()` and `base::subset()` are a little clearer and provide results we are more likely to want when filtering with `NA` values present. First `subset()`:\n\n> \"For ordinary vectors, the result is simply x[subset & !is.na(subset)].\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(dat, feature != 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n5     E       2\n9     I       2\n10    J       1\n11    K       2\n13    M       2\n15    O       2\n```\n:::\n:::\n\nAnd `dplyr::filter()` is clearer again:\n\n::: {.callout-tip}\n## From the dplyr::filter() documentation:\n\n\"The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, **the row must produce a value of TRUE for all conditions**. Note that when a condition evaluates to NA the row will be dropped, **unlike base subsetting with [**.\"\n\nðŸ‘€ [dplyr::filter() documentation](https://dplyr.tidyverse.org/reference/filter.html)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> dplyr::filter(feature != 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name feature\n1    A       1\n2    E       2\n3    I       2\n4    J       1\n5    K       2\n6    M       2\n7    O       2\n```\n:::\n:::\n\n\n## But what if I want the `NA` rows?!?!\n\nWell, we need to create a vector that explicitly includes the `NA` values:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$feature != 3 | is.na(dat$feature)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[13]  TRUE FALSE  TRUE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat[dat$feature != 3 | is.na(dat$feature),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n5     E       2\n6     F      NA\n8     H      NA\n9     I       2\n10    J       1\n11    K       2\n13    M       2\n15    O       2\n```\n:::\n\n```{.r .cell-code}\nsubset(dat, feature != 3 | is.na(feature))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n5     E       2\n6     F      NA\n8     H      NA\n9     I       2\n10    J       1\n11    K       2\n13    M       2\n15    O       2\n```\n:::\n\n```{.r .cell-code}\ndat |> dplyr::filter(feature != 3 | is.na(feature))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name feature\n1    A       1\n2    E       2\n3    F      NA\n4    H      NA\n5    I       2\n6    J       1\n7    K       2\n8    M       2\n9    O       2\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}