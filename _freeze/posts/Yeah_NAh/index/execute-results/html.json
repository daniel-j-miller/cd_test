{
  "hash": "9c326d304988209c325bdfc5d056cd9d",
  "result": {
    "markdown": "---\ntitle: \"Yeah NAh\"\nauthor: \"Dan Miller\"\ndate: \"2024-03-12\"\ncategories: [code]\n---\n\n\n\n## Filtering in R\n\nWhen we want to subset some data in R we have a few options, but really all of them under the hood are returning our data (often rows) based on logical, numeric or character indices.\n\nSo in the simplest form in base R we can use the ``[`` function to return the elements we want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return the first two elements using numeric indices:\nc(1,2,3)[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# And now Boolean:\nc(1,2,3)[c(TRUE,TRUE,FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# And how we would generally do it, by actually testing for equality\ndat <- c(1,2,3)\ndat[dat != 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\nBut what if our data has `NA` values?\n\n::: {.cell}\n\n```{.r .cell-code}\n# And how we would generally do it, by actually testing for equality\ndat <- c(1,2,3,NA)\ndat[dat != 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2 NA\n```\n:::\n:::\n\nThat looks ok, right? It's returning all the things that don't equal 3. But is it really return the `NA` value from the original `dat`? \n\nConsidering that we said we subset with logical, numeric or character indices, what does `dat != 3` return?\n\n::: {.cell}\n\n```{.r .cell-code}\ndat != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE    NA\n```\n:::\n:::\n\n`NA` is not one of the valid values for indexing. The documentation for `[` gives us a clue:\n\n> **NAs in indexing**:\n> When extracting, a numerical, logical or character *NA index* picks an *unknown element* and so returns NA in the corresponding element of a logical, integer, numeric, complex or character result, and NULL for a list. \n\nSo what does it matter? Well, it becomes clearer that it's not returning our original NA when we look at more complex data.\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(name = LETTERS[1:16], \n                  feature = sample(c(1:3,NA),16,replace = TRUE))\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n2     B      NA\n3     C       3\n4     D       1\n5     E      NA\n6     F       2\n7     G      NA\n8     H      NA\n9     I      NA\n10    J       1\n11    K       1\n12    L       3\n13    M       1\n14    N       2\n15    O       1\n16    P       2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_base <- dat[dat$feature != 3,]\ndat_base\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name feature\n1       A       1\nNA   <NA>      NA\n4       D       1\nNA.1 <NA>      NA\n6       F       2\nNA.2 <NA>      NA\nNA.3 <NA>      NA\nNA.4 <NA>      NA\n10      J       1\n11      K       1\n13      M       1\n14      N       2\n15      O       1\n16      P       2\n```\n:::\n:::\n\nThe rows where `feature` was `NA` are not returned, instead a whole missing row which is unlikely to ever be the desired result.\n\n## Filtering with NAs\n\n`dplr::filter()` and `base::subset()` are a little clearer and provide more likely results when filtering with `NA` values present. First `subset()`:\n> \"For ordinary vectors, the result is simply x[subset & !is.na(subset)].\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(dat, feature != 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n4     D       1\n6     F       2\n10    J       1\n11    K       1\n13    M       1\n14    N       2\n15    O       1\n16    P       2\n```\n:::\n:::\n\nAnd `dplyr::filter()` is clearer again:\n\n::: {.callout-tip}\n## From the dplyr::filter() documentation:\n\n\"The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, **the row must produce a value of TRUE for all conditions**. Note that when a condition evaluates to NA the row will be dropped, **unlike base subsetting with [**.\"\n\nðŸ‘€ [dplyr::filter() documentation](https://dplyr.tidyverse.org/reference/filter.html)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> dplyr::filter(feature != 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name feature\n1    A       1\n2    D       1\n3    F       2\n4    J       1\n5    K       1\n6    M       1\n7    N       2\n8    O       1\n9    P       2\n```\n:::\n:::\n\n\n## But what if I want the `NA` rows?!?!\n\nWell, we need to create a vector that explicitly includes the `NA` values:\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$feature != 3 | is.na(dat$feature)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[13]  TRUE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat[dat$feature != 3 | is.na(dat$feature),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n2     B      NA\n4     D       1\n5     E      NA\n6     F       2\n7     G      NA\n8     H      NA\n9     I      NA\n10    J       1\n11    K       1\n13    M       1\n14    N       2\n15    O       1\n16    P       2\n```\n:::\n\n```{.r .cell-code}\nsubset(dat, feature != 3 | is.na(feature))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n2     B      NA\n4     D       1\n5     E      NA\n6     F       2\n7     G      NA\n8     H      NA\n9     I      NA\n10    J       1\n11    K       1\n13    M       1\n14    N       2\n15    O       1\n16    P       2\n```\n:::\n\n```{.r .cell-code}\ndat |> dplyr::filter(feature != 3 | is.na(feature))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name feature\n1     A       1\n2     B      NA\n3     D       1\n4     E      NA\n5     F       2\n6     G      NA\n7     H      NA\n8     I      NA\n9     J       1\n10    K       1\n11    M       1\n12    N       2\n13    O       1\n14    P       2\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}